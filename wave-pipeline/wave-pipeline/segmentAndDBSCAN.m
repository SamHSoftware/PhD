%% segmentAndDBSCAN.m

% Author: Sam Huguet 
% Author e-mail: samhuguet1@gmail.com

% Purpose: This function clusters nuclei into colonies which it then tracks through multiple time points. 

% Function inputs: 
% gridsFolder [1×1 cell array] --> Cell contains a string with the parent directory containing the folders of mega-grids. 
% H2BChannel [int] --> If the channel for H2B is C01, enter 1 for this variable. 
% binFactor [double] --> The number of pixels in each axis which were binned. e.g. a binFactor of 4 would indicate that 4x4=16 pixels were binned into individual pixels. 
% lengthOfPixel = length of pixel in microns at current magnification. For 20x, it is 0.325.
% machineModel [struc] --> The random forest machine model loaded within the WavePipeline.m file. 

% Function outputs: For each well, creates a folder of corrected (tracked) images within gridsFolder. 

function segmentAndDBSCAN(gridsFolder, H2BChannel, binFactor, lengthOfPixel, machineModel)
 %%%%%% This function aims at performing the clustering and tracking of
 %%%%%% colonies through multiple time points. 

%% This portion of the script provides the directory that would otherwise be given by the main code. 
% gridsFolder = cell2mat(uipickfiles); % Select the files. 

delete(gcp('nocreate'));

wellFolders = dir(gridsFolder); % Get a list of all files and folders in this folder.
dirFlags = [wellFolders.isdir]; % Get a logical vector that tells which is a directory.
subFolders = wellFolders(dirFlags); % Extract only those that are directories.
wellDirectoryArray = cell(1,1); % Make a dataArray for storage of the wells.

clear wellDirectoryArray
for k = 1 : length(subFolders)
  if length(subFolders(k).name) < 3
    continue; 
  else 
      wellDirectoryArray(k,1) = {subFolders(k).name};
  end 
end

wellDirectoryArray = wellDirectoryArray(~cellfun('isempty',wellDirectoryArray)); % Remove empty cells and 'hey presto', you have all the subdirectories.

%% Loop through each of the wellscolonyIdentityLocations and create new folders with DBSCANNED images.

parpool(2) % Load up a parallel pool to speed things up (a bit). Here, we're running 2 DBSCANs at a time. 

for n = 9 : numel(wellDirectoryArray)
    %% Get the names of the images, and the number of images.
   
    s1 = 'progress_n___DBSCANning through wells ='; 
    value = num2str((n/length(wellDirectoryArray)*100));
    message = cell2mat(strcat(s1,{' '}, value));
    disp(message);
    
    s1 = gridsFolder;
    s2 = '\';
    s3 = wellDirectoryArray{n};
    wellDirectory = strcat(s1, s2, s3); % Construct the current directory that we want.

    cd(wellDirectory); % Change the current directory to that pertaining to the current well. 

    % list all the files within the directory and filter them, to remove
    % any funny single character names (e.g. '.') which I've seen appear.
    folderStruc = dir(cd); % Load the struc of the folder.
    gridNames = {folderStruc.name};
    numberOfImages = size(gridNames);
    numberOfImages = numberOfImages(2);
    nameLength =  cellfun('length',gridNames);
    logicalRepresentation = nameLength > 3;

    % Here are the correct names, generated by the process above. 
    gridNames = gridNames(logicalRepresentation);
    numberOfGrids = numel(gridNames);

    %% Remove all images from our list which aren't of the desired channel (We only want H2B).

    channelArray = cell(1,1); % Cell array to store information concerning well identity  

    gridNames = rot90(gridNames,3);% We need to rotate the name array for use later on. 

    for q=1:numberOfGrids
        % Extracting the first file name as a string. 
        Name = gridNames{q};

        % Extracting the well from the 'correctNames' string. 
        channel = Name(end-4:end-4);
        channel = {channel};
        channelArray(q,1) = channel; 
    end

    % We need to remove all names from the list which aren't of the red or
    % green channel. 
    channelArray = str2num(cell2mat(channelArray));
    x = ismember(channelArray, H2BChannel); % <-- Flag the ones that have '08' as their channel. 
    gridNames(~x) = []; % <-- Delete all the flagged lines at once.
    numberOfGrids = numel(gridNames); % The new number of grids having removed all the non-H2B ones. 
    
    %% Loop through the indiviual grids and DBSCAN them. 

    param.h_maxima          = 2.2;
size_threshold_microns_Squared = 21.16; % The area in microns squared. CHANGE THIS VALUE, NOT THE ONE BELOW, AS IT DEPENDS ON PIXEL SIZE AND BINNING.
    param.size_threshold = round(((sqrt(size_threshold_microns_Squared)/lengthOfPixel)^2)/binFactor^2); % Converting microns squared to pixels, taking into account the pixel size and binning value. 
param.show              = 0;

size_threshold_microns_Squared = 21.16; % The area in microns squared. CHANGE THIS VALUE, NOT THE ONE BELOW, AS IT DEPENDS ON PIXEL SIZE AND BINNING.
    param_CC.size_threshold = round(((sqrt(size_threshold_microns_Squared)/lengthOfPixel)^2)/binFactor^2); % Converting microns squared to pixels, taking into account the pixel size and binning value. 
param_CC.numNuclei = 10; % Minimum number of nuclei needed to detect 
elipse_microns = 43; % The elipse within which a neighboring nucleus can be considered part of the sam group.
param_CC.elipse = round((elipse_microns/lengthOfPixel)/binFactor); % Convert the number of microns to pixels. 

% Make a DBSCANNED-images directory. 
s1 = gridsFolder;
    s2 = '\';
    s3 = wellDirectoryArray{n};
    s4 = '_DBSCANNED';
    DBSCANNEDdir = strcat(s1, s2, s3, s4); % Construct the current directory that we want.
if ~exist(DBSCANNEDdir, 'dir') % If the directory doesn't exist, then create it. 
    cd (gridsFolder)
    mkdir(DBSCANNEDdir)
end

parfor w = 1:numberOfGrids % Segment and DBSCAN. Note: this is a parfor loop, my first! 
        
        s1 = 'progress_w___Loop through the indiviual grids and DBSCAN them ='; 
        value = num2str((w/numberOfGrids)*100);
        message = cell2mat(strcat({'   '},s1,{' '}, value));
        disp(message);
        
        cd(wellDirectory); % Change the current directory to that pertaining to the current well.
        
%             param.h_maxima          = 5;
%             param.otsu_thresh_index = 1;
%             param.otsu_coeff        = 1;
%             param.size_threshold    = 200;
%             param.method            = 'local_threshold';
%             param.n_class           = 2;
%             param.show              = 0;
%             param.threshold_local   = 3;
%             param.min_size_colony   = 10;
%             param.DICE_threshold    = 0.5;
%         grid = segmentation_nucleus_v2(grid,param); % Segment using manually deisgned method. 
%         grid = grid > 0;

                imageName = gridNames{w};
        [~, RGBprobss, nuclearMasks] = pixelClassifier2(imageName, machineModel, param);
       
        grid = ClusterColonies(nuclearMasks, param_CC); % Get the DBSCANNEd Image.
        grid = uint16(grid);
        
        % Save the image. 
        s1 = 'DBSCANNED';
        s2 = '_';
        s3 = cell2mat(gridNames(w));
            s3 = s3(1:end-4);
        s4 = '.tiff';
        outputFileName = strcat(s1, s2, s3, s4); % Construct the current directory that we want.
        cd (DBSCANNEDdir)
        imwrite(grid, outputFileName, 'Compression', 'none');
        
end 
    
end 

delete(gcp('nocreate')) % Get rid of the parralel pool. We can open up a new one later, if we need to (I'm sure I will). 

disp('segmentAndDBSCAN complete');

end 


