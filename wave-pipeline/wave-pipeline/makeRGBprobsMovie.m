% Preamble. 

binFactor = 4; % Amount of binning that the images have manually/artificially undergone.
lengthOfPixel = 0.325; %length of pixel at non-binned magnification.
machineModelFullPath = 'C:\Users\Samuel Huguet\Documents\Temporary Yoko data store\Testing the mahcine learning 4x4 binning\Training Data.mat';

%% Read in folder of images. 

% Open the folder (in this case a .tiff) needed for nuclear analysis. 
[Original_Im, Original_Path] = uigetfile('*.tif*');

cd(Original_Path);

% list all the files within the directory and filter them, to remove any funny single character names (e.g. '.') which I've seen appear.
allFiles = dir(Original_Path);
allNames = {allFiles.name};
numberOfImages = size(allNames);
numberOfImages = numberOfImages(2);
nameLength =  cellfun('length',allNames);
logicalRepresentation = nameLength > 5;

% Here are the correct names, generated by the process above. 
correctNames = allNames(logicalRepresentation);
numberOfCorrectNames = numel(correctNames);

%% Loop through images, classify them, then add them to a movie file. 

cd (Original_Path);

v = VideoWriter('ProbabilityMapMovie.mp4','Uncompressed AVI');
v.FrameRate = 4;
open(v);

s = VideoWriter('BinaryMapMovie.mp4','Uncompressed AVI');
s.FrameRate = 4;
open(s);

d = VideoWriter('NormalMapMovie.mp4','Uncompressed AVI');
d.FrameRate = 4;
open(d);

for k=1:numberOfCorrectNames 
    percentageCompletion = (k/numberOfCorrectNames)*100;
    percentageCompletion = num2str(percentageCompletion);
    s1 = 'Creating_movies_____';
    s3 = '%';
    message = strcat(s1, percentageCompletion, s3);
    disp(message); % This message tells us how far the loop we are. 

    cd (Original_Path); % Enter images directory. 
    
    load(machineModelFullPath); % Loads model. 
    machineModel = model;

        param.h_maxima                 = 2.2;
        size_threshold_microns_Squared = 21.16; % The area in microns squared. CHANGE THIS VALUE, NOT THE ONE BELOW, AS IT DEPENDS ON PIXEL SIZE AND BINNING.
            param.size_threshold = round(((sqrt(size_threshold_microns_Squared)/lengthOfPixel)^2)/binFactor^2); % Converting microns squared to pixels, taking into account the pixel size and binning value. 
        param.show                     = 0;    
    
    [adjustedIm, RGBprobs, nuclearMasks] = pixelClassifier2(correctNames{k}, machineModel, param);
    
    nuclearMasks = double(nuclearMasks);

    %% Write in the video frame.

    cd (Original_Path);
    writeVideo(v,RGBprobs);
    writeVideo(s,nuclearMasks);
    writeVideo(d,adjustedIm);

end

close(v); clear v;
close(s); clear s;
close(d); clear d;
